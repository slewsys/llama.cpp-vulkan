#!/usr/bin/env bash
#
# Copyright Â© 2025 Revolution Robotics, Inc.
#
# SPDX-License-Identifier: MIT
#
# @(#) install-llama.cpp-cuda
#
# This script installs llama.cpp with CUDA and Intel cuBLAS support.
#
: ${ASDF_CMD="${HOME}/bin/asdf"}
: ${AWK_CMD:='@AWK_CMD@'}
: ${CAT_CMD:='@CAT_CMD@'}
: ${CMAKE_CMD:='@CMAKE_CMD@'}
: ${ED_CMD:='@ED_CMD@'}
: ${GIT_CMD:='@GIT_CMD@'}
: ${GREP_CMD:='@GREP_CMD@'}
: ${MAKE_CMD:='@MAKE_CMD@'}
: ${PATCH_CMD:='@PATCH_CMD@'}
: ${PIP_CMD:="${HOME}/.asdf/shims/pip"}
: ${READLINK_CMD:='@READLINK_CMD@'}
: ${RM_CMD:='@RM_CMD@'}
: ${SORT_CMD:='@SORT_CMD@'}
: ${SUDO_CMD:='@SUDO_CMD@'}
: ${UPDATE_ALTERNATIVES_CMD:='@UPDATE_ALTERNATIVES_CMD@'}

: ${INSTALL_PREFIX:='/usr/local'}
: ${VULKAN_SDK_ROOT:='/opt/lunarg/vulkan'}

# OS-agnstoic readlink for existent files/directories.
resolve-existing ()
{
    if $READLINK_CMD --version 2>&1 | $GREP_CMD -q 'coreutils'; then
        $READLINK_CMD -e "$@"
    else
        $READLINK_CMD -f N "$@"
    fi
}

set-alternatives ()
{
    local name=$1
    local path=$2

    if command -v "$UPDATE_ALTERNATIVES_CMD" >/dev/null; then
        if $UPDATE_ALTERNATIVES_CMD --list |
                $AWK_CMD '{ print $1 }' |
                $GREP_CMD -q "^${name}\>" &&
                test -f "$path"; then
            $SUDO_CMD $UPDATE_ALTERNATIVES_CMD --set "$name" "$path"
        fi
    fi
}

check-vulkan-env ()
{
    local vulkan_sdk_root=$1

    if test ."$VULKAN_SDK" = .'' -o ! -d "$VULKAN_SDK" \
            || [[ ! ."$VULKAN_SDK" =~ ^\.$vulkan_sdk_root ]]; then
        if test ! -f "${vulkan_sdk_root}/config.json"; then
            ${script_dir}/install-vulkan-sdk "$vulkan_sdk_root" || return $?
        fi
    fi

    local arch=''
    local version=''

    arch=$($UNAME_CMD -m) || return $?
    version=$($JQ_CMD -r '.version' "${vulkan_sdk_root}/config.json") || return $?

    export VULKAN_SDK=${vulkan_sdk_root}/${version}/${arch} \
           LD_LIBRARY_PATH=${VULKAN_SDK}/lib${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH} \
           VL_ADD_LAYER_PATH=${VULKAN_SDK}/share/vulkan/explicit_layer.d \
           PKG_CONFIG_PATH=${VULKAN_SDK}/share/pkgconfig:${VULKAN_SDK}/lib/pkgconfig${PKG_CONFIG_PATH:+:$PKG_CONFIG_PATH}
}

verify-python ()
{
    local version=$1

    pushd "${script_dir}" >/dev/null || return $?

    trap 'exit 1' 0 1 2 15 RETURN

    if ! command -v "$ASDF_CMD" >/dev/null && test -x "${HOME}/bin/asdf"; then
        export PATH=${PATH}:${HOME}/bin
    fi

    if command -v "$ASDF_CMD" >/dev/null; then
        if [[ ! ."$PATH" =~ ^\..*\.asdf/shims ]]; then
            export PATH=${HOME}/.asdf/shims:${PATH}
        fi

        python_available=$(
            $ED_CMD -s <($ASDF_CMD list) <<EOF
g/^python/1,.d
g/^[a-z]/.,\$d
, !$GREP_CMD "$version" | $SORT_CMD -V
p
Q
EOF
                        ) || return $?

        case "$python_available" in
            *'*'${version}*)
                : Nothing to do
                ;;
            *${version}*)
                if test -f "${script_dir}/.tool-versions"; then
                    $CP_CMD -a "${script_dir}/.tool-versions"{,."$script_name"} || return $?
                    $SED_CMD -i -e "s/^python.*/python${python_available}/" \
                             "${script_dir}/.tool-versions" || return $?
                else
                    echo "python${python_available}" >${script_dir}/.tool-versions
                fi
                ;;
            *)
                $ASDF_CMD plugin add python || return $?
                latest=$(eval $ASDF_CMD latest python "$version")
                $ASDF_CMD install python "$latest" || return $?
                $ASDF_CMD set python "$latest" || return $?
                ;;
        esac
    else
        ${script_dir}/install-asdf || return $?
        $ASDF_CMD plugin add python || return $?
        latest=$(eval $ASDF_CMD latest python "$version")
        $ASDF_CMD install python "$latest" || return $?
        $ASDF_CMD set python "$latest" || return $?
        $ASDF_CMD reshim python || return $?

        export PATH=${HOME}/.asdf/shims:${PATH}:${HOME}/bin
    fi

    popd >/dev/null || return $?

    trap - 0 1 2 15 RETURN
}

install-llama.cpp ()
{
    local srcdir=$1

    local builddir=${srcdir}/build

    if test ! -d "$builddir"; then
        echo "${script_name}: ${builddir}: No such file or directory." >&2
        echo "${script_name}: Please build llama.cpp first." >&2
        return 1
    fi

    $SUDO_CMD $MAKE_CMD -C "$builddir" install || return $?

    # gguf.py support for MXFP4 not yet released.
    $PIP_CMD install "${srcdir}/gguf-py" || return $?
}

if test ."$0" = ."${BASH_SOURCE[0]}"; then
    declare script=''
    declare script_dir=''
    declare script_name=''

    script=$(resolve-existing "$0") || exit $?
    script_name=${script##*/}
    script_dir=${script%/*}

    if (( EUID == 0 )); then
        echo "${script_name}: This script must not be run by user root." >&2
        exit 1
    fi

    declare top_srcdir=''

    top_srcdir=$(
        cd "$script_dir" && $GIT_CMD rev-parse --show-toplevel
              ) || true

    declare abs_srcdir=${1:-"$top_srcdir"}
    declare vulkan_sdk_root=${2:-"$VULKAN_SDK_ROOT"}

    declare llama_srcdir=${script_dir}/src/llama.cpp
    declare py_version='3\.11'

    echo "Installing llama.cpp with ROCm and Intel cuBLAS support" >&2

    check-vulkan-env "$vulkan_sdk_root" || exit $?
    verify-python "$py_version" || exit $?
    # set-alternatives gcc /usr/bin/x86_64-linux-gnu-gcc-15 || exit $?
    # set-alternatives g++ /usr/bin/x86_64-linux-gnu-g++-15 || exit $?
    # set-alternatives gfortran /usr/bin/x86_64-linux-gnu-gfortran-15 || exit $?
    install-llama.cpp "$llama_srcdir" || exit $?
fi
